# Vue3

## 构建方式

1. vue3 使用 rollup 进行构建

2. 每个模块功能都是单独一个包 有 自己的 package.json

   >runtime-dom 、runtime-core、reactivity。。。

3. 每个模块打包完会在@vue的目录下，实现各个包功能共享

4. 每一个包的功能都可以单独使用

   ```js
   //package.json的大致内容
   {
     "name": "@vue/reactivity",
     "version": "1.0.0",
     "main": "index.js",
     "license": "MIT",
     "module": "dist/reactivity.esm-bundler.js",
     "buildOptions":{
       "name":"VueReactivity",
       "formats":[
         "cjs",
         "esm-bundler",
         "global"
       ]
     }
   }
   
   //包引用
   export * from "@vue/reactivity"
   ```



## 响应式API

### reactive/readonly/shallowReactive/shallowReadonly

> packages\reactivity\src\reactive.ts

1. 采用函数柯里化 四个方法 调用同一个方法 通过不同参数来实现方法  createReactiveObject

2. 代理的值必须是对象

3. 通过 Proxy 实现代理

4. 在 handerls 里定义 get 和 set方法   createGetter  createSetter packages\reactivity\src\baseHandlers.ts

   > vue2 是 一开始就通过递归进行深层代理
   >
   > vue3 是在 get 取值的时候 判断如果为对象在进行代理

   ```js
   //  ./reactive.ts
   function createReactiveObject(target, isReadOnly, handerls) {
     if (!isObject(target)) {
       return target
     }
     const proxyMap = isReadOnly?readonlyMap: reactiveMap
     const existProxy = proxyMap.get(target)
     if (existProxy) {
       return existProxy
     }
   const handerls = {
     get,
     set, 
     deleteProperty,
     has,
     ownKeys
   }
     const proxy = new Proxy(target, handerls)
     proxyMap.set(target, proxy)
     return proxy
   }
   ```

### ref

>packages\reactivity\src\ref.ts
>
>ref 通过 class RefImpl 实现

1. 在 class 里定义 get 和 set 去实现
2. 通过 trackRefValue 和 triggerRefValue 去处理依赖

### watch

packages\runtime-core\src\apiWatch.ts

1. doWatch

   1. 先判断 监听目标类型 转成对应的 getter 函数
   2. 通过 ReactiveEffect 生成 effect
   3. 执行 effect.run() =>目标属性走 get 方法 将 watch的 effect 与 目标 dep 进行依赖绑定
   4. 在 目标 值发生变化 会执行 watch 的 effect.scheduler()
      - scheduler 为 watch的 cb 进行封装
      - callWithAsyncErrorHandling 来执行 最后的 cb

### compute

packages\runtime-core\src\apiComputed.ts=》packages\reactivity\src\computed.ts

1. 判断是否只读

   > const onlyGetter = isFunction(getterOrOptions)
   >
   > 如果为函数代表只有 get  getter = getterOrOptions
   >
   > 否则 取 getterOrOptions 的 get 和set 
   >
   > getter = getterOrOptions.get
   >
   > setter = getterOrOptions.set

2. 通过 ComputedRefImpl 类生成计算属性

   > 类似 ref 本质也是 通过 get set 去实现依赖收集执行

   1. 创建一个 ReactiveEffect

   2. 取值时 调用 get 方法，同时执行 trackRefValue 进行依赖绑定

      > _dirty 默认为 true
      >
      > 取值时 执行 get 在get 里 将 _dirty 设为 false 同时执行getter 获取最新值
      >
      > 当该计算属性 涉及到的属性发生变化时 会触发 scheduler的 triggerRefValue 执行对应的依赖  _dirty=true
      >
      > 如果没有取值 _dirty永远为true  scheduler里的代码不会执行

      ```js
      public _dirty = true
      
      constructor(
          getter: ComputedGetter<T>,
          private readonly _setter: ComputedSetter<T>,
          isReadonly: boolean,
          isSSR: boolean
        ) {
          this.effect = new ReactiveEffect(getter, () => {
              //scheduler
            if (!this._dirty) {
              this._dirty = true
              triggerRefValue(this)
            }
          })
          //.......
        }
      get value() {
          const self = toRaw(this)
          trackRefValue(self)
          if (self._dirty || !self._cacheable) {
            self._dirty = false
            self._value = self.effect.run()!
          }
          return self._value
        }
      ```



## 依赖收集/执行 ReactiveEffect

> packages\reactivity\src\effect.ts

   通过 ReactiveEffect 创建 effect，将effect 与 属性 dep 进行关联，在属性改变时 执行 创建 effect 时 传入的相关函数。

1. 在属性取值时在 get中通过 track 方法与该 effect进行关联 

   - 将 整个 reactive对象 存入 targetMap( = new WeakMap() ) 

     > targetMap.set(target, (depsMap = new Map()))

   - 将 监听到的 key  存入 depsMap 

     > depsMap.set(key, (dep = createDep()))

   - 将 当前 activeEffect 与 dep 相关关联

     > dep.add(activeEffect)
     >
     > activeEffect.deps.push(dep)

2. 在 属性赋值 set 中 通过 trigger 执行依赖

   - 获取 当前key 的dep

   - 执行当前 effect 的 更新函数

     > if (effect.scheduler) {
     >
     >    effect.scheduler()
     >
     >   } else {
     >
     >    effect.run()
     >
     >   }



## 模板编译

packages\vue\src\index.ts  => compileToFunction

1. 通过 compile（packages\compiler-dom\src\index.ts） 生成 可执行函数 字符串

   - compile =》baseCompile 里的 baseParse 生成 ast

   - baseParse  =》 执行 parseChildren 获取 ast 数组

   - generate（packages\compiler-core\src\codegen.ts） 生成字符串



## 页面初次渲染流程

createApp 

> runtime-dom

1. 执行  ensureRenderer() 创建包括各个方法的对象

   ```js
   // renderer.ts
   {
       render,
       hydrate,
       createApp: createAppAPI(render, hydrate)
     }
   ```

2.  执行 createApp 获取 app对象

3. 执行 app.mount方法 渲染页面

   1. 执行 render 方法
   2.  processComponent =》mountComponent=》setupRenderEffect =》完成渲染
4. mountComponent   packages\runtime-core\src\component.ts
   - 通过 setupComponent（。。。=》handleSetupResult=》finishComponentSetup=》compileToFunction） 生成 render 方法（模板编译）
   
   - setupRenderEffect 
     
     - 执行 ReactiveEffect 生成 effect 
     
       ```js
       const effect = (instance.effect = new ReactiveEffect(
             componentUpdateFn,
             () => queueJob(update),
             instance.scope // track it in component's effect scope
       ))
       const update: SchedulerJob = (instance.update = () => effect.run())
       ```
     
       
     
     - 在 componentUpdateFn 里通过 renderComponentRoot 把 instance 解析成可渲染 数组
     - patch 进行页面渲染

## 生命周期

packages\runtime-core\src\apiLifecycle.ts

1. 执行 createHook 生成各个生命周期函数
2. 在 injectHook 中 会传入当前 currentInstance，将执行生命周期传入的 函数 push 进对应的currentInstance[LifecycleHooks.]
3. 在对应的时期 遍历 currentInstance[LifecycleHooks.] 去执行函数

```typescript
const createHook =

 <T extends Function = () => any>(lifecycle: LifecycleHooks) =>

 (hook: T, target: ComponentInternalInstance | null = currentInstance) =>

  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)

  (!isInSSRComponentSetup || lifecycle === LifecycleHooks.SERVER_PREFETCH) &&

   injectHook(lifecycle, (...args: unknown[]) => hook(...args), target)


function injectHook(
  type: LifecycleHooks,
  hook: Function & { __weh?: Function },
  target: ComponentInternalInstance | null = currentInstance,
  prepend: boolean = false
){
      const hooks = target[type] || (target[type] = [])
      .......
      hooks.push(wrappedHook)
  }


const onMounted = createHook(LifecycleHooks.MOUNTED)
.....
```









